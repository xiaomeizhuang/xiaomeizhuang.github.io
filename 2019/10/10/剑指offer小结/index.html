<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  

  
  <title>剑指offer小结 | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="抱着好奇心翻开了剑指offer，原来是50道编程题的解题啊。随便翻了一下翻到第23题，发现讲得很通俗易懂，所以决定要把它看完（还没有看完，也不是按顺序看）。可是仔细看时发现，有些题解只描述了过程，为什么这样做却没有直白地写出来，所以我在解释部分补充了一点点自己的思考，包括具体讨论判断条件或者边界条件的情况，还包括草图（加载有点儿慢）。语言用的是C++，草图用Ilustrator画会比较久，所以暂时">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer小结">
<meta property="og:url" content="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/index.html">
<meta property="og:site_name">
<meta property="og:description" content="抱着好奇心翻开了剑指offer，原来是50道编程题的解题啊。随便翻了一下翻到第23题，发现讲得很通俗易懂，所以决定要把它看完（还没有看完，也不是按顺序看）。可是仔细看时发现，有些题解只描述了过程，为什么这样做却没有直白地写出来，所以我在解释部分补充了一点点自己的思考，包括具体讨论判断条件或者边界条件的情况，还包括草图（加载有点儿慢）。语言用的是C++，草图用Ilustrator画会比较久，所以暂时">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/3_240.jpg">
<meta property="og:image" content="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/8_153_1_2.jpg">
<meta property="og:image" content="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/8_153_2_2.jpg">
<meta property="og:image" content="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/15_19.jpg">
<meta property="og:image" content="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/16_206.jpg">
<meta property="og:image" content="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/22_946.jpg">
<meta property="og:image" content="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/23_102.jpg">
<meta property="og:image" content="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/25_113.jpg">
<meta property="og:image" content="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/26_138.jpg">
<meta property="og:updated_time" content="2019-10-23T06:47:45.958Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer小结">
<meta name="twitter:description" content="抱着好奇心翻开了剑指offer，原来是50道编程题的解题啊。随便翻了一下翻到第23题，发现讲得很通俗易懂，所以决定要把它看完（还没有看完，也不是按顺序看）。可是仔细看时发现，有些题解只描述了过程，为什么这样做却没有直白地写出来，所以我在解释部分补充了一点点自己的思考，包括具体讨论判断条件或者边界条件的情况，还包括草图（加载有点儿慢）。语言用的是C++，草图用Ilustrator画会比较久，所以暂时">
<meta name="twitter:image" content="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/3_240.jpg">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
</html>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="https://github.com/xiaomeizhuang">Github</a>
        
          <a class="main-nav-link" href="/About">About</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xiaomeizhuang.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-剑指offer小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/10/剑指offer小结/" class="article-date">
  <time datetime="2019-10-10T13:50:36.000Z" itemprop="datePublished">2019-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      剑指offer小结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      <!-- Table of Contents -->
      
        <div id="toc" class="toc-article">
          <strong class="toc-title">目录</strong>
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值运算符函数"><span class="toc-number">1.</span> <span class="toc-text">赋值运算符函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现singleton模式"><span class="toc-number">2.</span> <span class="toc-text">实现Singleton模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维数组中的查找"><span class="toc-number">3.</span> <span class="toc-text">二维数组中的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#替换空格"><span class="toc-number">4.</span> <span class="toc-text">替换空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从头到尾打印链表"><span class="toc-number">5.</span> <span class="toc-text">从头到尾打印链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重建二叉树"><span class="toc-number">6.</span> <span class="toc-text">重建二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用两个栈实现队列"><span class="toc-number">7.</span> <span class="toc-text">用两个栈实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#旋转数组的最小数字"><span class="toc-number">8.</span> <span class="toc-text">旋转数组的最小数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#斐波那契数列"><span class="toc-number">9.</span> <span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制中1的个数"><span class="toc-number">10.</span> <span class="toc-text">二进制中1的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数值的整数次方"><span class="toc-number">11.</span> <span class="toc-text">数值的整数次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打印1到最大的n位数"><span class="toc-number">12.</span> <span class="toc-text">打印1到最大的n位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在o1时间删除链表节点"><span class="toc-number">13.</span> <span class="toc-text">在O(1)时间删除链表节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调整数组顺序使奇数位于偶数前面"><span class="toc-number">14.</span> <span class="toc-text">调整数组顺序使奇数位于偶数前面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表中倒数第n个结点"><span class="toc-number">15.</span> <span class="toc-text">链表中倒数第n个结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反转链表"><span class="toc-number">16.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#合并两个排序的链表"><span class="toc-number">17.</span> <span class="toc-text">合并两个排序的链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树的子结构"><span class="toc-number">18.</span> <span class="toc-text">树的子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的镜像"><span class="toc-number">19.</span> <span class="toc-text">二叉树的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺时针打印矩阵"><span class="toc-number">20.</span> <span class="toc-text">顺时针打印矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包含min函数的栈"><span class="toc-number">21.</span> <span class="toc-text">包含min函数的栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈的压入弹出序列"><span class="toc-number">22.</span> <span class="toc-text">栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从上往下打印二叉树"><span class="toc-number">23.</span> <span class="toc-text">从上往下打印二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉搜索树的后序遍历序列"><span class="toc-number">24.</span> <span class="toc-text">二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树中和为某一值的路径"><span class="toc-number">25.</span> <span class="toc-text">二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂链表的复制"><span class="toc-number">26.</span> <span class="toc-text">复杂链表的复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉搜索树与双向链表"><span class="toc-number">27.</span> <span class="toc-text">二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串的排列"><span class="toc-number">28.</span> <span class="toc-text">字符串的排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组中出现次数超过一半的数字"><span class="toc-number">29.</span> <span class="toc-text">数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小的k个数"><span class="toc-number">30.</span> <span class="toc-text">最小的k个数</span></a></li></ol>
        </div>
      
        <p>抱着好奇心翻开了剑指offer，原来是50道编程题的解题啊。随便翻了一下翻到第23题，发现讲得很通俗易懂，所以决定要把它看完（还没有看完，也不是按顺序看）。可是仔细看时发现，有些题解只描述了过程，为什么这样做却没有直白地写出来，所以我在解释部分补充了一点点自己的思考，包括具体讨论判断条件或者边界条件的情况，还包括草图（加载有点儿慢）。语言用的是C++，草图用Ilustrator画会比较久，所以暂时先把稿纸拍上来😝（邮箱在About页，如果有错误可以得到指正再好不过啦～ <a id="more"></a></p>
<h3 id="赋值运算符函数">赋值运算符函数</h3>
<p>题目：</p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="实现singleton模式">实现Singleton模式</h3>
<p>题目：</p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="二维数组中的查找">二维数组中的查找</h3>
<p>题目：<a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">leetcode：240. Search a 2D Matrix II</a></p>
<p>解释：</p>
<p>书中没有直白地解释为什么从数组的右上角开始遍历，只是按照某个例子展开讲了从右上角遍历的这个过程。所以自己认真思考了一下那是为什么从右上角（或者左下角）开始寻找呢？首先数组的任意行和列都是升序，利用这个规律，可以得知对于某个元素<span class="math inline">\(a[i][j]\)</span>，它的左上角，以及它所在行的左侧和所在列的上部分组成的区域（蓝色）内的元素，都不会大于这个元素，它的右下角，以及它所在行的右侧和所在列的下部分组成的区域（紫色）内的元素都不会小于这个元素。按照常理从左上角开始搜索，会导致搜索路径不明确，也就是向右或者向下都可。但是从右上角搜索，不会有这种模糊，比如和待检索元素A相比，如果<span class="math inline">\(a[i][j]&lt;A\)</span>那么搜索路径向左移动，<span class="math inline">\(a[i][j]&gt;A\)</span>那么搜索路径向下移动，<span class="math inline">\(a[i][j]=A\)</span>那么就意味着已找到所需的元素。从左下角B开始搜索与从右上角A同理。</p>
<p><img src="3_240.jpg"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span> || matrix[<span class="number">0</span>].size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rows=matrix.size(), columns=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=columns<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;rows &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==target) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&gt;target)</span><br><span class="line">                --j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="替换空格">替换空格</h3>
<p>题目：</p>
<p><a href="https://algorithms.tutorialhorizon.com/replace-all-spaces-in-a-string-with/" target="_blank" rel="noopener">Algorithms：Replace all spaces in a String with '%20'</a></p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="从头到尾打印链表">从头到尾打印链表</h3>
<p>题目：</p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="重建二叉树">重建二叉树</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" target="_blank" rel="noopener">leetcode：105. Construct Binary Tree from Preorder and Inorder Traversal</a></p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="用两个栈实现队列">用两个栈实现队列</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">leetcode：232. Implement Queue using Stacks</a></p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="旋转数组的最小数字">旋转数组的最小数字</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">leetcode：153. Find Minimum in Rotated Sorted Array</a></p>
<p>解释：</p>
<p>通过遍历筛选出数组最小的元素也是可行的，但是这个数组有序（只不过更小的一部分被旋转到数组的后方），因此可以试试二分搜索。</p>
<p>对于数组搜索范围start到end，如果nums[start] &lt; nums[end]，说明start已经是最小值，直接返回nums[start]（图中绿色）；如果nums[start] &gt; nums[end]，那么最小值在其中的第二个升序序列的起点。前者是特殊情况，下面讨论后者该怎么分析：</p>
<p>用二分搜索缩小范围时，第一种情况（图中红色）：如果最小值在数组的右侧，说明第一个升序序列长度大于数组半长，那么缩小搜索范围时撇去mid左侧的元素，包括mid处的元素，因为它位于第一个升序序列中，不可能是最小值，新范围直接从mid+1处开始；第二种情况（图中蓝色）：如果最小值在数组的左侧，说明第二个升序序列的长度大于数组半长，那么缩小搜索范围时撇去mid之后的序列，不包括mid处的元素，因为它位于第二个升序序列，也有可能是最小值，新范围到mid处为止。如何表示缩小范围所依据的判断条件呢，用mid所在位置的元素B的大小判断，如果大于该搜索范围的start处的元素A，说明是第一种情况；如果小于该搜索范围的start元素A，说明是第二种情况。再分析一下边界条件：</p>
<p>第一种情况到达临界时，也就是缩小范围直到start，mid，end相邻，mid和end之间不再可能会有最小值，因此end处的元素C自然是最小值。第二种情况到达临界时，同样会缩小范围直到start，mid，end相邻，start和mid之间不再可能会有最小值，因此mid处的元素B就是最小值。不可能有A&gt;B&gt;C的情况，因为是两个升序序列拼接，最多只有不升序的两个相邻元素。</p>
<p><img src="8_153_1_2.jpg"></p>
<p>补充一下：while循环中的nums[sart]&lt;=nums[end]这个判断条件中考虑到等于的情况，有三种可能，数组只有一个元素时；旋转0个元素时；当该轮搜索范围的start=end时，意味着缩小范围直到end处，最小值位于end处（图中红色）。</p>
<p>nums[mid]&gt;=nums[start]中为什么也考虑到相等呢？一开始我没有加上等号，leetcode上提交始终是wrong。排除元素重复的原因，根据上面所讲的第二种情况的临界，缩小范围到start和end相邻，当它们相等时，意味着mid和start指向同一个元素，这时候最小值是与mid位置相邻的end上的元素，C。</p>
<p>下面用一个12个元素的序列示例，列举了最小值可能在所有位置的情况下，找最小值的过程中start, mid, end的取值。</p>
<p><img src="8_153_2_2.jpg"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>, end=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)<span class="comment">//还有这里可以控制输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//第一个元素已经是最小，说明旋转0个元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[start]&lt;=nums[end])</span><br><span class="line">                <span class="keyword">return</span> nums[start];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=nums[start])</span><br><span class="line">                start=mid+<span class="number">1</span>;<span class="comment">//说明mid在左侧的上升序列</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end=mid;<span class="comment">//说明mid在右侧的上升序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="斐波那契数列">斐波那契数列</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">leetcode：509. Fibonacci Number</a></p>
<p>解释：</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> firstNum=<span class="number">0</span>, secondNum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fibSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N; ++i)&#123;</span><br><span class="line">            fibSum=firstNum+secondNum;</span><br><span class="line">            firstNum=secondNum;</span><br><span class="line">            secondNum=fibSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fibSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="二进制中1的个数">二进制中1的个数</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">leetcode：191. Number of 1 Bits</a></p>
<p>解释：</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> onecount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; flag) </span><br><span class="line">                onecount++;</span><br><span class="line">            flag=flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onecount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="数值的整数次方">数值的整数次方</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">leetcode：50. Pow(x, n)</a></p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="打印1到最大的n位数">打印1到最大的n位数</h3>
<p>题目：</p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="在o1时间删除链表节点">在O(1)时间删除链表节点</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">leetcode：237. Delete Node in a Linked List</a></p>
<p>解释：</p>
<p>只知道一个待删除结点node，因此通过node的后序结点来取代待删除结点，从而做到删除node。根据ListNode数据结构，将后序结点的next指针和val变量赋到node中，再delete掉后序结点。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//node不是尾结点</span></span><br><span class="line">        ListNode *next=node-&gt;next; </span><br><span class="line">        node-&gt;next=next-&gt;next;<span class="comment">//把next指针赋过去</span></span><br><span class="line">        node-&gt;val=next-&gt;val;<span class="comment">//把val值赋过去</span></span><br><span class="line">        <span class="keyword">delete</span> next;</span><br><span class="line">        next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="调整数组顺序使奇数位于偶数前面">调整数组顺序使奇数位于偶数前面</h3>
<p>题目：</p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="链表中倒数第n个结点">链表中倒数第n个结点</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">leetcode：19. Remove Nth Node From End of List</a></p>
<p>解释：</p>
<p>这个关于倒数第k个结点的题，leetcode中要求删除，剑指offer要求输出，下面按照leetcode的要求处理。</p>
<p>题目要求一次遍历，因此先遍历一次统计出结点个数，计算倒数第k个结点的顺序位置，再遍历第二次找到该结点的方法不可行。</p>
<p>1.倒数第n个结点和正数第n个结点对称，可以用双指针一次遍历找到倒数第n个结点；</p>
<p>2.先把Ahead指针移动到第n个结点处，由于Ahead一开始就是指向head处，因此只需要移动n-1次；</p>
<p>3.当Ahead指针指向正数第n个结点，此时Behind指针指向第一个结点， 两者同时向后移动，当Ahead指针指向最后一个结点时，Behind指针就指向了倒数第n个结点；</p>
<p>4.虽然找到了倒数第n个结点，但是为了删除它我们还需它的前序结点，如果按照前面再多设一个指针也可以，但是比较麻烦。所以这次移动Ahead指针n次，然后找倒数第n+1个结点，这样还可以间接得到它的后序结点，也就是待删除结点。如果n为链表长度（也就是删除第一个结点），那么移动n次Ahead指针会刚好指向NULL，此时直接返回head-&gt;next；</p>
<p>5.把Behind-&gt;next指针指向下下个结点，就可以从链表中删除倒数第n个结点啦～</p>
<p><img src="15_19.jpg"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//一前一后两个位置相差n的指针</span></span><br><span class="line">        ListNode* Ahead = head;</span><br><span class="line">        ListNode* Behind = head;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            Ahead = Ahead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果Ahead走n步后指向NULL，说明n为链长，舍弃第一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(Ahead==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(Ahead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Ahead = Ahead-&gt;next;</span><br><span class="line">            Behind = Behind-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* deletedNode=Behind-&gt;next;</span><br><span class="line">        Behind-&gt;next = Behind-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> deletedNode;</span><br><span class="line">        <span class="comment">//不能用head，因为n为head的情况下会被删掉</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="反转链表">反转链表</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">leetcode：206. Reverse Linked List</a></p>
<p>解释：</p>
<p>对于这个单链表，如果修改某个结点的next指针，不再指向下个结点，意味着它和后面的链表断开了（图中A情况），所以首先要把后面的结点保存下来（P1指针），同时也需要挂住已经反转的部分防止丢失，因此需要一个指针指向上一个刚刚修改完的结点（P2指针），这种情况下，当P2指向的结点修改next指针时，还是会导致和后面的链表断开（图中B情况），因此P2指针指向正在修改的结点，再多一个P3指针保存之后的结点（图中C情况）。这三个指针向后移动从而逐个修改结点的next指针。</p>
<p><img src="16_206.jpg"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pHeadNode=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pNode=head;<span class="comment">//正在反转的结点</span></span><br><span class="line">        ListNode* pPrevNode=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pNode!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* pNextNode=pNode-&gt;next;<span class="comment">//挂住即将断开的链表的后边结点</span></span><br><span class="line">            <span class="keyword">if</span>(pNextNode==<span class="literal">NULL</span>)</span><br><span class="line">                pHeadNode=pNode;<span class="comment">//保存头结点，因为最后返回链表，而不是单个结点</span></span><br><span class="line">            pNode-&gt;next=pPrevNode;</span><br><span class="line">            pPrevNode=pNode;</span><br><span class="line">            pNode=pNextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHeadNode;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="合并两个排序的链表">合并两个排序的链表</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">leetcode：21. Merge Two Sorted Lists</a></p>
<p>解释：</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果一个为空，那么返回另一个</span></span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* mergeHead=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            mergeHead=l1;</span><br><span class="line">            mergeHead-&gt;next=mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            mergeHead=l2;</span><br><span class="line">            mergeHead-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="树的子结构">树的子结构</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">leetcode：572. Subtree of Another Tree</a></p>
<p>解释：</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result =<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s!=<span class="literal">NULL</span> &amp;&amp; t!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s-&gt;val == t-&gt;val)<span class="comment">//只有根节点相等但是后面都不等，还得能继续找，不能直接返回false</span></span><br><span class="line">                result=hasSubtree(s,t);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result=(isSubtree(s-&gt;left,t)||isSubtree(s-&gt;right,t));<span class="comment">//递归，继续找左右子节点有没有相等的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasSubtree</span><span class="params">(TreeNode*s, TreeNode* t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">NULL</span> &amp;&amp; t==<span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">NULL</span> || t==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val != t-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>(hasSubtree(s-&gt;left,t-&gt;left) &amp;&amp; hasSubtree(s-&gt;right,t-&gt;right));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="二叉树的镜像">二叉树的镜像</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">leetcode：226. Invert Binary Tree</a></p>
<p>解释：</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode *NodeTemp=root-&gt;left;</span><br><span class="line">        root-&gt;left=root-&gt;right;</span><br><span class="line">        root-&gt;right=NodeTemp;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            invertTree(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            invertTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="顺时针打印矩阵">顺时针打印矩阵</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">leetcode：54. Spiral Matrix</a></p>
<p>解释：</p>
<p>书中通过举个简单的例子来说明边界条件总的行数rows大于该圈起点的列数rowBegin乘2，这个边界条件的得出不太好理解。换句话说，假设已经遍历到了最内圈，此时最起码有一个元素，算列或行，即总的列数rows - rowBegin x 2 &gt;= 1，也就是书中的rows &gt; rowBegin x 2。每打印完一行或一列，就更新行数和列数，所以下面用的边界条件是rowBegin&lt;=rowEnd。</p>
<p>在顺时针的这一圈中，打印完第一行时，++rowBegin，因为</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> rows=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> columns=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> rowBegin=<span class="number">0</span>,rowEnd=rows<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> colBegin=<span class="number">0</span>,colEnd=columns<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(rowBegin&lt;=rowEnd &amp;&amp; colBegin&lt;=colEnd)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=colBegin; j&lt;=colEnd; ++j)&#123;</span><br><span class="line">                result.push_back(matrix[rowBegin][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳到下一行</span></span><br><span class="line">            ++rowBegin;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//rowBegin可能会大于rowEnd，如果大的话不会进行这个for循环</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=rowBegin; i&lt;=rowEnd; ++i)&#123;</span><br><span class="line">                result.push_back(matrix[i][colEnd]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减去这一列</span></span><br><span class="line">            --colEnd;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(rowBegin&lt;=rowEnd)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=colEnd; j&gt;=colBegin; --j)&#123;</span><br><span class="line">                    result.push_back(matrix[rowEnd][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//上一行</span></span><br><span class="line">                --rowEnd;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(colBegin&lt;=colEnd)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=rowEnd; i&gt;=rowBegin; --i)&#123;</span><br><span class="line">                    result.push_back(matrix[i][colBegin]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//右一列</span></span><br><span class="line">                ++colBegin;</span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="包含min函数的栈">包含min函数的栈</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">leetcode：155. Min Stack</a></p>
<p>解释：</p>
<p>假设用一个变量来保存最小值，每次入栈元素更小时就更新这个变量的值，但是当这个最小值弹出之后无法得到新的最小值，因此还需要保存次小值，❓❓</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; StackData;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; StackMin;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        StackData.push(x);</span><br><span class="line">        <span class="keyword">if</span>(StackMin.empty() || x&lt;=getMin())<span class="comment">//=是考虑同时有两个以上相等的最小值</span></span><br><span class="line">            StackMin.push(x);<span class="comment">//不用像剑指offer那样重复放入最小值，因为getmin不弹出</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StackData.top()==getMin())</span><br><span class="line">            StackMin.pop();</span><br><span class="line">        StackData.pop();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StackData.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StackMin.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="栈的压入弹出序列">栈的压入、弹出序列</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">leetcode：946. Validate Stack Sequences</a></p>
<p>解释：</p>
<p>判断所给的入栈序列和出栈序列是不是指同一个栈。因此建立一个辅助栈，按照入栈序列来将元素放入栈中，再判断能否按照出栈序列出栈，入栈和出栈的操作掺杂一起，因此同一个入栈序列可以对应不同的出栈序列。以入栈序列1,2,3,4,5和出栈序列4,3,2,5,1为例，首先出栈的是4，那么需要元素1,2,3,4依次入栈，毕竟只有4在栈顶时才能将它弹出。因此，每次入栈一个元素都需要判断它（栈顶元素）是不是下一个出栈序列的元素，如果相等弹出，重复这个过程知道栈顶元素不等于下一个出栈元素为止，这时候继续将入栈序列中之后的元素入栈，❓❓❓</p>
<p><img src="22_946.jpg"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed.size()!=popped.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stackdata;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> data:pushed)</span><br><span class="line">        &#123;</span><br><span class="line">            stackdata.push(data);<span class="comment">//先push，然后判断是否相等，每次</span></span><br><span class="line">            <span class="keyword">while</span>(stackdata.size() &amp;&amp; popped[i]==stackdata.top())<span class="comment">//连续pop出321</span></span><br><span class="line">            &#123;</span><br><span class="line">                stackdata.pop();</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackdata.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="从上往下打印二叉树">从上往下打印二叉树</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">leetcode：102. Binary Tree Level Order Traversal</a></p>
<p>解释：</p>
<p>以图中右上角的二叉树为例。按层打印，那么首先从根结点A开始，打印完A就要立刻打印其下一层子结点B和C，因此打印A的时候我们需要提前考虑保存它的子结点；打印第二层B和C时，当遍历到B时同样需要考虑提前保存其子结点。上面这个粗略的过程符合先进先出的原则，因此选择用队列来保存结点。注意的是，每开始新的一轮遍历之前首先统计一次队列当前的结点数量n，遍历过程中经过每个结点时不仅要从队列中弹出自身然后保存到动态数组，而且要存储自身的子结点，等到遍历结束，而此时队列存放的又是完全的新一层的所有结点。把动态数组存放到result中，继续进行新一轮的遍历。</p>
<p><img src="23_102.jpg"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; LevelNode;</span><br><span class="line">        LevelNode.push(root);<span class="comment">//根节点放入queue中</span></span><br><span class="line">        <span class="keyword">while</span>(!LevelNode.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; EachLevel;<span class="comment">//每次循环都会创建一个vector</span></span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt;::size_type n=LevelNode.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">queue</span>&lt;TreeNode*&gt;::size_type i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//遍历queue，放入vector中</span></span><br><span class="line">                TreeNode* node =LevelNode.front();</span><br><span class="line">                LevelNode.pop();</span><br><span class="line">                EachLevel.push_back(node-&gt;val);</span><br><span class="line">                <span class="comment">//跳到下一层，放入queue中，然后等着下一次循环放入新vector中</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                    LevelNode.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                    LevelNode.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(EachLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="二叉搜索树的后序遍历序列">二叉搜索树的后序遍历序列</h3>
<p>题目：相似题lintcode1307</p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="二叉树中和为某一值的路径">二叉树中和为某一值的路径</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">leetcode：113. Path Sum II</a></p>
<p>解释：</p>
<p>由于需要选出所有和为sum的路径，因此会遍历所有的结点。用什么遍历方式呢？当从根结点出发后，沿着某个子结点前进，直到最终到达叶节点，如果这条根到叶的路径上所有结点之和不等于sum，那么就需要逐步后退换另一个子结点（不满足要求的子结点的兄弟结点）尝试求和，这个过程类似前序遍历。在前序遍历的基础上，用栈存储路径的结点，前进一步就往栈中加入结点以及往sum加入该结点的值，回退一步就从栈中弹出结点以及从sum减去该结点的值，符合条件的路径保存在另一个栈中。</p>
<p><img src="25_113.jpg"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allpaths;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> allpaths;</span><br><span class="line">        <span class="keyword">int</span> CurrentSum=<span class="number">0</span>;</span><br><span class="line">        pathSum(root, sum, CurrentSum);</span><br><span class="line">        <span class="keyword">return</span> allpaths;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span>&amp; CurrentSum)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前结点的值入栈，计算CurrentSum</span></span><br><span class="line">        CurrentSum+=root-&gt;val;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">//是不是叶节点用bool变量表示</span></span><br><span class="line">        <span class="keyword">bool</span> isLeaf= root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//如果是叶节点而且和达到sum</span></span><br><span class="line">        <span class="keyword">if</span>(CurrentSum==sum &amp;&amp; isLeaf)&#123;</span><br><span class="line">            allpaths.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            pathSum(root-&gt;left, sum, CurrentSum);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            pathSum(root-&gt;right, sum, CurrentSum);</span><br><span class="line">        CurrentSum-=root-&gt;val;</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="复杂链表的复制">复杂链表的复制</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">leetcode 138. Copy List with Random Pointer</a></p>
<p>解释：</p>
<p>操作1.2.3.用三个函数表示：</p>
<p>1.复制结点：CloneNode指代当前在复制的结点，CloneEach指代正在复制的原始结点，向右移动挨个复制每个节点的val值和next指针给CloneNode，random指针暂时设置为NULL；</p>
<p>2.复制random指针：OriginalNode指代这条链中的原始结点，CloneNode指代复制结点，后者跟着前者向右移动挨个复制random指针；</p>
<p>3.分离出两个链：CloneHead为分离后复制链的头指针，CloneNode指代复制结点，OriginalNode指代原始结点，同步向右移动修改next指针。</p>
<p>为什么要单独复制random指针：因为这个链表只有指向右侧结点的指针，但每个结点的random指针可能会指向左侧的结点，如此，复制random指针时无可避免地就需要从头遍历去寻找其指向的结点，对于n个结点的链表而言，每复制一个结点的random指针需要遍历n个结点，时间<span class="math inline">\(O(n^2)\)</span>。</p>
<p><img src="26_138.jpg"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next, Node* _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        CloneNodes(head);</span><br><span class="line">        ConnectRandom(head);</span><br><span class="line">        <span class="keyword">return</span> ReconnectNodes(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制结点：</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloneNodes</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *CloneEach = head;</span><br><span class="line">        <span class="comment">//CloneEach到达链尾NULL时停止：</span></span><br><span class="line">        <span class="keyword">while</span>(CloneEach!=<span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//复制过程：</span></span><br><span class="line">            Node *CloneNode=<span class="keyword">new</span> Node();</span><br><span class="line">            CloneNode-&gt;val = CloneEach-&gt;val;</span><br><span class="line">            CloneNode-&gt;next=CloneEach-&gt;next;</span><br><span class="line">            CloneNode-&gt;random=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//CloneEach向右移动到新的待复制结点：</span></span><br><span class="line">            CloneEach-&gt;next=CloneNode;</span><br><span class="line">            CloneEach=CloneNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制random指针：</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ConnectRandom</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *OriginalNode = head;</span><br><span class="line">        <span class="keyword">while</span>(OriginalNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *CloneNode=OriginalNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(OriginalNode-&gt;random!=<span class="literal">NULL</span>)</span><br><span class="line">                CloneNode-&gt;random=OriginalNode-&gt;random-&gt;next;</span><br><span class="line">            OriginalNode=CloneNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分离出两个链：</span></span><br><span class="line">    <span class="function">Node *<span class="title">ReconnectNodes</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node *OriginalNode = head;</span><br><span class="line">        Node *CloneNode = <span class="literal">NULL</span>;</span><br><span class="line">        Node *CloneHead =<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(OriginalNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            CloneHead = CloneNode = OriginalNode-&gt;next;</span><br><span class="line">            OriginalNode-&gt;next = CloneNode-&gt;next;</span><br><span class="line">            OriginalNode = OriginalNode-&gt;next;   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(OriginalNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            CloneNode-&gt;next = OriginalNode-&gt;next;</span><br><span class="line">            CloneNode = CloneNode-&gt;next;</span><br><span class="line">            OriginalNode-&gt;next = CloneNode-&gt;next;</span><br><span class="line">            OriginalNode = OriginalNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="二叉搜索树与双向链表">二叉搜索树与双向链表</h3>
<p>题目：锁住了</p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="字符串的排列">字符串的排列</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">leetcode：46. Permutations</a></p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="数组中出现次数超过一半的数字">数组中出现次数超过一半的数字</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">leetcode：169. Majority Element</a></p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>
<h3 id="最小的k个数">最小的k个数</h3>
<p>题目：</p>
<p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">leetcode：215. Kth Largest Element in an Array</a></p>
<p>解释：</p>
<p>代码：</p>
<p><br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xiaomeizhuang.github.io/2019/10/10/剑指offer小结/" data-id="ck2334iv5000278l7xkmt2xdo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/10/22/面向对象程序设计-魔兽世界/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          面向对象程序设计-魔兽世界
        
      </div>
    </a>
  
  
    <a href="/2019/10/09/为什么B-树适合作为索引的结构/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">为什么B+树适合作为索引的结构</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 <br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="https://github.com/xiaomeizhuang" class="mobile-nav-link">Github</a>
  
    <a href="/About" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>